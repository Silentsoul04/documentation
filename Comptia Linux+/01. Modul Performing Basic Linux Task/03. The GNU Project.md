# The GNU Project

#### The GNU Project

The _**GNU Project**_ is a free software project led by Richard Stallman. Announced in 1983, it was the first project of its kind, and effectively launched the free software movement. The GNU Project's goal is to create an operating system that is composed of entirely free software. By the early 1990s, the GNU Project had not completed a full OS, but had created several programs. Stallman wrote much of the GNU software himself, including the GNU C Compiler (GCC) and the Emacs text editor. Later, several programmers worked together to develop more utilities that are compatible with GNU software.

Stallman chose the recursive acronym "GNU's Not Unix" to show that GNU software was similar in design to the proprietary Unix operating system, but did not actually contain any Unix code.

> Note: The "G" in GNU is included in the pronunciation of the term "guh-NOO."

**_FREE SOFTWARE FOUNDATION AND THE GNU GPL_**

Shortly after kicking off the GNU Project, Stallman founded the nonprofit _**Free Software Foundation (FSF)**_ to promote the philosophy behind free software. Stallman and the FSF created the _**GNU General Public License (GPL)**_ to support the GNU Project. One of the requirements of the GPL is that any derivative of a GPL work must also be distributed under that same licenseâ€”a concept known as _**copyleft.**_

#### The Unix Philosophy

Because GNU software is based on the design of Unix, it tends to conform to the _**Unix philosophy.**_ The Unix philosophy is a set of best practices and approaches to software development that emphasize simplicity and modularity. This philosophy was created by the lead developers of the Unix operating system and has been summarized in many ways. Some of the key high-level points include:

-   **Do one thing and do it well.** Rather than writing a monolithic software tool that accomplishes a variety of disparate tasks, write individual tools that fulfill a specific function.
-   **Worse is better.** Software that is limited in functionality ("worse") is often preferable ("better") because it tends to be easier to use and maintain.
-   **Support interactivity.** Write individual tools so that they work well with other tools.
-   **Handle input/output streams.** Feeding one tool's output as input into another tool is a universally desirable feature.